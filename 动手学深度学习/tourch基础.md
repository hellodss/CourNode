---
title: "深度学习Tourch基础"
date: 2024-010-19-16:14
---
# 深度学习Tourch基础

## 关于张量
首先，我们介绍一下张量n维数组，也称为张量（tensor）。 使用过Python中NumPy计算包的读者会对本部分很熟悉。 无论使用哪个深度学习框架，它的张量类（在MXNet中为ndarray， 在PyTorch和TensorFlow中为Tensor）都与Numpy的ndarray类似。 但深度学习框架又比Numpy的ndarray多一些重要功能： 首先，GPU很好地支持加速计算，而NumPy仅支持CPU计算； 其次，张量类支持自动微分。 这些功能使得张量类更适合深度学习。 如果没有特殊说明，本书中所说的张量均指的是张量类的实例。

## 基本操作
张量的基本操作包括张量的创建、索引、切片、维度变换、拼接、广播等。 我们将在后面的章节中详细介绍这些操作。
```python
// 以下代码创建一个形状为（3,4）的张量。 其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样。
torch.randn(3, 4)
```
    tensor([[-0.0135,  0.0665,  0.0912,  0.3212],
        [ 1.4653,  0.1843, -1.6995, -0.3036],
        [ 1.7646,  1.0450,  0.2457, -0.7732]])

### **张量的连接**，
即拼接，是指沿着某个轴（维度）将多个张量拼接在一起。 张量的拼接操作有两种形式：按行拼接（dim=0）和按列拼接（dim=1）。 按行拼接就是沿着行维度将多个张量拼接在一起，按列拼接就是沿着列维度将多个张量拼接在一起。 以下代码展示了按行拼接和按列拼接的例子。
```python
X = torch.arange(12, dtype=torch.float32).reshape((3,4))
Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1)
```
    (tensor([[ 0.,  1.,  2.,  3.],
            [ 4.,  5.,  6.,  7.],
            [ 8.,  9., 10., 11.],
            [ 2.,  1.,  4.,  3.],
            [ 1.,  2.,  3.,  4.],
            [ 4.,  3.,  2.,  1.]]),
     tensor([[ 0.,  1.,  2.,  3.],
            [ 4.,  5.,  6.,  7.],
            [ 8.,  9., 10., 11.],
            [ 2.,  1.,  4.,  3.],
            [ 1.,  2.,  3.,  4.],
            [ 4.,  3.,  2.,  1.]]))

### **张量的广播**（broadcasting）
是指对两个张量进行算术运算时，如果它们的形状不一致，则自动将其扩展到同样的形状。 广播的规则是，如果两个张量的某个维度的长度是1，则在该维度上进行广播。 以下代码展示了张量的广播。
```python
a = torch.arange(3).reshape((3, 1))
b = torch.arange(2).reshape((1, 2))
a + b
```
    tensor([[0, 1],
            [1, 2],
            [2, 3]])

## 自动求导
深度学习框架的张量类支持自动求导。 这意味着，我们可以不通过手动计算导数，而是让框架自动生成导数的代码。 这样可以节省大量的计算时间。 我们只需要调用backward函数，然后就可以得到各个变量的导数。 以下代码展示了如何使用自动求导。
```python
x = torch.tensor(2.0, requires_grad=True)
y = 3 * x ** 2
y.backward()
print(x.grad)
```
    tensor(6.0000)

在上面的例子中，我们创建了一个标量变量x，并设置它的requires_grad属性为True。 然后我们计算y=3*x**2。 最后，我们调用backward函数，得到y关于x的导数，并打印出来。 由于x是一个标量变量，所以它的导数恒为3*2=6。 我们可以继续对其他变量求导，得到它们的导数。


##  转换为其他Python对象
将深度学习框架定义的张量转换为NumPy张量（ndarray）很容易，反之也同样容易。 torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。
```python
A = X.numpy()
B = torch.tensor(A)
type(A), type(B)
Copy to clipboard
(numpy.ndarray, torch.Tensor)
// 要将大小为1的张量转换为Python标量，我们可以调用item函数或Python的内置函数。

mxnet
pytorch
tensorflow
paddle
a = torch.tensor([3.5])
a, a.item(), float(a), int(a)
Copy to clipboard
(tensor([3.5000]), 3.5, 3.5, 3)

```